{% extends "layout.html" %}

{% block title %}
    Nexus
{% endblock %}

{% block main %}
    <div class="row justify-content-center mt-3 mb-5">
        <div class="col-12">
            <img src="/static/image.png" class="main_image mx-auto d-block" alt="image of water representing the unconscious">
        </div>
    </div>
    <div class="row justify-content-center text-center mt-5 mb-5">
        <div class="col-9" id="poem_type" data-poem-type="">
            <p class="h2 lines" id="line1"></p>
            <p class="h2 lines" id="line2"></p>
            <p class="h2 lines" id="line3"></p>
        </div>
        <div>
            <button id="likeButton" class="btn btn-default swap mt-2">
                <i class="bi bi-heart"> </i>
            </button>
            <button class="btn btn-default mt-2" type="button" id="customizeButton" data-bs-toggle="modal" data-bs-target="#customizeModal">
                <i class="bi bi-pencil" id="pencilIcon"></i>
            </button>
        </div>
    </div>

    {% if get_flashed_messages() %}
    <div class="row justify-content-center">
        <div class="col-3 text-center flash-message mb-3" role="alert">
            {{ get_flashed_messages() | join(" ") }}: "{{ line }}"
        </div>
    </div>
    {% endif %}

    <div class="row justify-content-center text-center">
        <div class="col-6">
            <form action="/entry" method="post">
                <div class="input-group mb-2">
                    <input type="text" name="line" placeholder="checkout the tooltip" class="form-control placeholder-text">
                    <button class="btn" type="button" id="tooltipButton" data-bs-toggle="modal" data-bs-target="#tooltipModal">
                        <i class="bi bi-info-circle"></i>
                    </button>
                </div>
                <button class="btn mt-2" type="submit">Cast</button>
            </form>
        </div>
    </div>

    <!-- Customize Modal -->
    <div class="modal fade" id="customizeModal" tabindex="-1" aria-labelledby="customizeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="customizeModalLabel">Select a Line (checkout tooltip first)</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="text" id="searchInput" class="form-control mb-3" placeholder="Search your lines...">
                    <div class="list-group" id="userLinesList" style="max-height: 300px; overflow-y: auto;">
                        <!-- User lines will be appended here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="saveSelectedLine">Save</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Tooltip Modal -->
    <div class="modal fade" id="tooltipModal" tabindex="-1" aria-labelledby="tooltipModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="tooltipModalLabel">What is this?</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              This is an experiment to see if 3 randomly selected lines shared by participants can become a poem you find meaningful.<br>
              My intention is to point to interconnectedness (with/without, comes/no) and synchronicity (randomly assembled poem that you find meaningful).<br>
              Originally, I was playing with the idea of self-organized poems but that became too complicated and I wanted to start with something simpler.<br>
              <br>
              As a participant, you get to share 1 line but you must follow 1 of 2 formats.<br>
              1: With (word), comes (word); (1-4 words)<br>
              2: Without (word), no (word); (1-4 words)<br>
              [case insensitive â€” don't forget the comma and semicolon!]<br>
              <br>
              I hope you find this kind of fun ^^<br>
              If you want to have the poem display at least 1 of your line, click the pencil<br>
              Currently there are ~100 lines are 99% were generated by GPT
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
          </div>
        </div>
      </div>
    <!-- <div class="input-group mb-3">
        <span class="input-group-text">Without</span>
        <input type="text" class="form-control" placeholder="Username" aria-label="Username">
        <span class="input-group-text">, no </span>
        <input type="text" class="form-control" placeholder="Server" aria-label="Server">
        <button class="btn mt-3" type="submit">Cast</button>
      </div> -->
      


    
<script> 
    let selectedLineId = null;

    $(document).ready(function() {
    // Fetch user data when the customize button is clicked
    $('#customizeButton').on('click', function() {
        // Check if a line is already selected
        if (selectedLineId) {
            // Unselect the line and reset the icon
            selectedLineId = null;
            $('#pencilIcon').removeClass('bi-pencil-fill').addClass('bi-pencil');
            return;
        }
        
        $.ajax({
            url: '/customize',
            type: 'POST',
            success: function(data) {
                let userLinesList = $('#userLinesList');
                userLinesList.empty(); // Clear previous entries
                data.forEach(function(line) {
                    userLinesList.append(
                        `<a href="#" class="list-group-item list-group-item-action" data-line-id="${line.id}">
                            ${line.line}
                        </a>`
                    );
                });

                // Handle line selection
                $('.list-group-item').on('click', function() {
                    $('.list-group-item').removeClass('active');
                    $(this).addClass('active');
                    selectedLineId = $(this).data('line-id');
                });
            },
            error: function() {
                alert('Error fetching user data');
            }
        });
    });

    // Save the selected line
    $('#saveSelectedLine').on('click', function() {
        if (selectedLineId) {
            fetchLines(selectedLineId);
            $('#customizeModal').modal('hide');
            $('#pencilIcon').removeClass('bi-pencil').addClass('bi-pencil-fill');
        } else {
            alert('Please select a line');
        }
    });

    function fetchLines(selectedLineId = null) {
        let url = '/get_entries';
        if (selectedLineId) {
            url += `?poemID=${selectedLineId}&customize=1`;
        }
        fetch(url)
            .then(response => response.json())
            .then(data => {
                // Set the identifier in line0
                document.getElementById('poem_type').dataset.poemType = data.lines[0].poem_type;

                // Apply the pop animation class to lines 1, 2, and 3
                document.getElementById('line1').classList.add('pop');
                document.getElementById('line2').classList.add('pop');
                document.getElementById('line3').classList.add('pop');

                // Remove the pop class after animation and update content
                setTimeout(() => {
                    // Clear previous content and classes
                    clearAndAnimateLine('line1', data.lines[1].line, data.lines[1].id);
                    clearAndAnimateLine('line2', data.lines[2].line, data.lines[2].id);
                    clearAndAnimateLine('line3', data.lines[3].line, data.lines[3].id);

                    // Update the like button based on liked status
                    updateLikeButton(data.liked, data.likes);
                }, 600); // 600ms matches the duration of the pop animation
            })
            .catch(error => console.error('Error fetching lines:', error));
    }

    function updateLikeButton(liked, likeCounter) {
        const likeButtonIcon = $('#likeButton i');
        const likeButton = $('#likeButton');

        if (liked) {
            likeButtonIcon.addClass('bi-heart-fill').removeClass('bi-heart');
            likeButton.addClass('swap');
        } else {
            likeButtonIcon.addClass('bi-heart').removeClass('bi-heart-fill');
            likeButton.addClass('swap'); // Ensure the swap class is always applied
        }

        if (likeCounter > 0) {
            likeButtonIcon.text(` ${likeCounter}`);
        } else {
            likeButtonIcon.text('');
        }
    }

    function clearAndAnimateLine(elementId, text, id) {
        const lineElement = document.getElementById(elementId);
        lineElement.innerHTML = ''; // Clear previous content
        lineElement.classList.remove('pop');
        lineElement.dataset.lineId = id; // Set the data-line-id attribute with the line ID
        lineElement.dataset.lineText = text; // Set the data-line-text attribute with the line text

        // Split text into letters and spaces, and wrap each letter in a span
        const letters = text.split('');
        const indices = Array.from(letters.keys());

        // Shuffle indices to randomize the appearance order
        shuffle(indices);

        for (let i = 0; i < letters.length; i++) {
            const span = document.createElement('span');
            span.textContent = letters[i];
            if (letters[i] === ' ') {
                span.classList.add('space');
            } else {
                span.classList.add('letter');
                // Apply animation delay based on shuffled order
                span.style.animation = `letter-appear 1s ${indices[i] * 0.07}s forwards`;
            }
            lineElement.appendChild(span);
        }
        lineElement.classList.add('bubble-up');
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // Fetch new lines every 15 seconds
    setInterval(fetchLines, 15600); // 15 seconds + 600ms pop animation

    // Initial fetch
    fetchLines();

    jQuery(function($) {
        $('#likeButton').on('click', function() {
            var poemType = document.getElementById('poem_type').dataset.poemType;
            var line1Id = document.getElementById('line1').dataset.lineId;
            var line1Text = document.getElementById('line1').dataset.lineText;
            var line2Id = document.getElementById('line2').dataset.lineId;
            var line2Text = document.getElementById('line2').dataset.lineText;
            var line3Id = document.getElementById('line3').dataset.lineId;
            var line3Text = document.getElementById('line3').dataset.lineText;

            $.ajax({
                url: '/like',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    poem_type: poemType,
                    lines: [
                        { id: line1Id, text: line1Text },
                        { id: line2Id, text: line2Text },
                        { id: line3Id, text: line3Text }
                    ]
                }),
                success: function(response) {
                    if (response.success) {
                        var likeCounter = parseInt($('#likeButton i').text()) || 0;
                        if (response.liked) {
                            likeCounter++;
                        } else {
                            likeCounter--;
                        }
                        updateLikeButton(response.liked, likeCounter);
                    } else {
                        alert('Error liking lines');
                    }
                },
                error: function() {
                    alert('Error liking lines');
                }
            });
        });
    });
});




</script>



{% endblock %}


